1)write a sql query to find customer who spent more than 1000 rupees in the last month using orders and order_items tables

SELECT
    t2.CustomerID, t2.CustomerName, SUM(t1.Amount) AS total_spent
FROM
    Sales t1
JOIN
    Customers t2 ON t1.CustomerID = t2.CustomerID
GROUP BY
    t2.CustomerID, t2.CustomerName
HAVING
    SUM(t1.Amount) >= 1000


Another way you can do this :

SELECT * FROM 
    (SELECT t2.CustomerID, t2.CustomerName, 
     SUM(t1.Amount) AS total_spent FROM Sales t1
     JOIN Customers t2 ON t1.CustomerID = t2.CustomerID
     GROUP BY t2.CustomerID, t2.CustomerName 
    ) AS Result
WHERE total_spent >= 1000

========================================================================

To find the highest purchase amount for each customer, use the SQL MAX() function with the GROUP BY clause.

SELECT customer_id , MAX(order_price) AS HighestPurchase
FROM customer_order_details
GROUP BY customer_id;

===============================================================================


First, let's create a database and a customer_order_details table.




CREATE TABLE customer_order_details(
    customer_id VARCHAR(20),
    customer_name VARCHAR(20),
    order_id VARCHAR(20),
    order_price INT
);

INSERT INTO customer_order_details
VALUES
    ('C1098', 'PRADEEP', 'O3006', 20000),
    ('C1098', 'PRADEEP', 'O3010', 5000),
    ('C1098', 'PRADEEP', 'O3016', 600),
    ('C1100', 'KIRAN', 'O3068', 1000),
    ('C1100', 'KIRAN', 'O3075', 200),
    ('C1195', 'PRANAV', 'O3072', 6000),
    ('C1195', 'PRANAV', 'O3045', 80000),
    ('C2026', 'BUTCHI RAJU', 'O3056', 100000),
    ('C2026', 'BUTCHI RAJU', 'O3058', 20000);



SELECT * FROM customer_order_details;



--------------------------------------------------------------------------------

SQL Query to Find the Highest Purchase Amount of a Customer


SELECT customer_id , MAX(order_price) AS HighestPurchase
FROM customer_order_details
GROUP BY customer_id 
ORDER BY MAX(order_price) DESC;


-------------------------------------------------------------------------------

2)

find the top 3 customer by total purchase amount per month using window functions

tables :-
Product
Sales
Customer



with t as 
(
 select 
    s.cust_id,
    date_trunc('month', "Date") as period,
    s.quantity * p.product_price as amount 
 from sales s join product p on s.product_id = p.product_id
 group by period, s.cust_id
), 
r as
(
 select *,
    row_number() over (partition by period order by amount desc) as rank
 from t
)
select r.period, c.name as cust_name, r.rank as period_rank
from r join customer c on r.cust_id = c.id
where rank <= 3 
order by r.period, r.rank;

------------------------------------------


With this, functions such as SUM(), AVG(), ROW_NUMBER(), RANK() and DENSE_RANK() can be applied in a controlled way.


SELECT column_name1, 
       window_function(column_name2) 
       OVER ([PARTITION BY column_name3] [ORDER BY column_name4]) AS new_column
FROM table_name;




window_function: Any aggregate or ranking function (SUM(), AVG(), ROW_NUMBER(), etc.)
column_name1: Regular column(s) to be selected in the outputand column_name2: Column on which the window function is applied
column_name3: Column used for dividing rows into groups (PARTITION BY)and column_name4: Column used to define order of rows within each partition (ORDER BY)
new_column: Alias for calculated result of the window function
table_name: table from which data is selected



1. Aggregate Window Function
Aggregate window functions calculate aggregates over a window of rows while retaining individual rows. Common aggregate functions include:

SUM(): Sums values within a window.
AVG(): Calculates the average value within a window.
COUNT(): Counts the rows within a window.
MAX(): Returns the maximum value in the window.
MIN(): Returns the minimum value in the window.
Example: Using AVG() to Calculate Average Salary within each department


SELECT Name, Age, Department, Salary, 
       AVG(Salary) OVER( PARTITION BY Department) AS Avg_Salary
 FROM employee


2. Ranking Window Functions
These functions provide rankings of rows within a partition based on specific criteria. Common ranking functions include:

RANK(): Assigns ranks to rows, skipping ranks for duplicates.
DENSE_RANK(): Assigns ranks to rows without skipping rank numbers for duplicates.
ROW_NUMBER(): Assigns a unique number to each row in the result set.
PERCENT_RANK(): Shows the relative rank of a row as a percentage between 0 and 1.


SELECT Name, Department, Salary,
       RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS emp_rank
FROM employee;


2.2 DENSE RANK Function
When ranking rows in SQL, ties can sometimes create gaps in the ranking sequence. DENSE_RANK() function is used to avoid this it assigns the same rank to rows with equal values but continues ranking with the next consecutive number, without skipping.

Example: Using DENSE_RANK() to Rank Employees by Salary


SELECT Name, Department, Salary,
       DENSE_RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS emp_dense_rank
FROM employee;


2.3 ROW NUMBER Function
ROW_NUMBER() gives e­ach row a unique number. It numbers rows from one­ to the total rows. The rows are put into groups base­d on their values. Each group is called a partition. In e­ach partition, rows get numbers one afte­r another. No two rows have the same­ number in a partition.

Example: Using ROW_NUMBER() for Unique Row Numbers


SELECT Name, Department, Salary,
       ROW_NUMBER() OVER(PARTITION BY Department ORDER BY Salary DESC) AS emp_row_no
FROM employee;


2.4 PERCENT RANK Function
PERCENT_RANK() shows the relative position of a row compared to others in the same partition. The formula is:

Example: Using PERCENT_RANK() to Find Relative Salary Position


SELECT Name, Department, Salary,
       PERCENT_RANK() OVER(PARTITION BY Department ORDER BY Salary DESC) AS emp_percent_rank
FROM employee;




=======================================================================================================

3)

write a query to calculate net revenue per day considering returns data,



Method 1: Using SUM() with OVER(ORDER BY) to Track Cumulative Revenue
This query calculates the total revenue *up to* each row, sorted by sale_date. The magic happens in the OVER clause, which tells SQL to sum values from the beginning of the dataset to the current row — giving you that running total effect.

SELECT 
    sale_date, 
    product, 
    revenue,
    SUM(revenue) OVER (
        ORDER BY sale_date 
        ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
    ) AS running_total
FROM Sales;



Method 2: Daily Aggregation Followed by Running Total
We first calculate total revenue for each date using a Common Table Expression (CTE). Then, we apply the same running total logic to these daily totals. This is especially helpful when you’re less concerned with individual sales and more interested in day-by-day performance.


WITH DailyRevenue AS (
    SELECT 
        sale_date,
        SUM(revenue) AS daily_total
    FROM Sales
    GROUP BY sale_date
)
SELECT 
    sale_date,
    daily_total,
    SUM(daily_total) OVER (ORDER BY sale_date) AS running_total
FROM DailyRevenue;



Method 3: Running Totals for Each Product (Bonus Tip!)
If you want to track how revenue accumulates over time for each individual product — say, you’re analyzing product performance — this query does the job beautifully. Using PARTITION BY, SQL resets the running total for each unique product.


SELECT 
    sale_date,
    product,
    revenue,
    SUM(revenue) OVER (
        PARTITION BY product 
        ORDER BY sale_date
    ) AS product_running_total
FROM Sales;


